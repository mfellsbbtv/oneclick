You are a senior full-stack engineer tasked with designing and implementing a secure, web-based “Account Provisioning” app. It collects a new hire’s basic info, lets an admin toggle which apps to create accounts for, gathers per-app required fields, then provisions those accounts and assigns licenses. Deliver production-quality code and documentation.

## Primary Objective

Build a web app that:

1. Page 1 collects:

   * Full Name (required)
   * Work Email (required; unique)
   * Toggles for: Google Workspace, Slack, Microsoft 365, ClickUp, Jira, Confluence, GitHub, Zoom, HubSpot (at least one must be ON)
   * “Next” button is disabled until Name + Email are valid and ≥1 toggle is ON
2. Subsequent pages:

   * One page per selected app to collect required fields for that app
   * Validation per app, “Next/Back,” progress indicator
3. Submission:

   * Create accounts and assign licenses in each selected app
   * Show per-app results, errors, and remediation guidance
   * Persist audit log and configuration for reproducibility

## Target Stack (adjust if you can prove a better default)

* Frontend: React + TypeScript (Next.js, server actions), form state with React Hook Form + Zod validation
* Backend: Node.js (NestJS or Express + TypeScript)
* Persistence: PostgreSQL (users, requests, app-specific metadata, audit logs)
* Queue/Jobs: Redis + BullMQ for provisioning tasks and retries
* Secrets: environment variables via a secrets manager (Vault, or .env for local)
* AuthN for operators: SSO via OIDC (administrator users only)
* Deployment: Docker; provide Docker Compose for local dev

## Integrations and Provisioning Strategy

Prefer SCIM or official admin APIs. Implement idempotent “create or fetch” flows to avoid duplicates.

* Google Workspace: Admin SDK Directory API for users; Licensing API for Google Workspace SKU assignment.
* Slack: SCIM API for user creation, user activation; assign to default workspace/user groups if applicable.
* Microsoft 365: Microsoft Graph API to create user, assign licenses (SKU/plan), and set usage location.
* ClickUp: Public API to invite user to workspace, set role/team membership.
* Atlassian: Use Atlassian Admin/SCIM for user provisioning; assign products Jira and Confluence and default groups.
* GitHub: Enterprise/Org API to invite user by email, add to org teams, set role.
* Zoom: Zoom Admin API to create user (auto-activation), assign license type (Basic/Pro).
* HubSpot: HubSpot Admin API to create user and assign roles/permissions.

Implement a provider interface:

```ts
interface Provisioner {
  validate(input: unknown): Promise<ValidatedInput>;
  plan(input: ValidatedInput): Promise<Plan>;          // what actions will be taken
  apply(input: ValidatedInput): Promise<Result>;       // create/update; must be idempotent
}
```

Each app gets a module that implements `validate/plan/apply`. Store external IDs returned.

## Data Model (initial)

* `users`: id, full\_name, work\_email, created\_at
* `provisioning_requests`: id, user\_id, requested\_apps\[], status, created\_by, created\_at
* `app_configs`: id, app, fields jsonb, created\_at (per-app collected fields)
* `app_results`: id, request\_id, app, status enum(pending/success/partial/error), external\_user\_id, external\_links jsonb, raw\_response jsonb, error\_message, created\_at
* `audit_logs`: id, actor, action, target, metadata jsonb, created\_at

## UX Requirements

* Stepper wizard with clear validation, inline errors, and a summary review before submission.
* Per-app form pages populated dynamically based on toggles from page 1.
* After run: a results dashboard with filter by status, CSV export, and “Retry failed step” button per app.
* Accessibility: keyboard navigation, ARIA where appropriate.

## Validation Rules

* Name: non-empty string, 2+ chars.
* Email: RFC 5322 valid, corporate domain pattern configurable.
* At least one app selected on page 1.
* Per-app fields enforced (see “Per-App Fields” below).

## Per-App Fields (collect on dedicated pages)

* Google Workspace: primary org unit (default), initial password policy toggle, license SKU selection.
* Slack: default channel invites, user role (member/admin), user groups.
* Microsoft 365: usage location, license SKUs and service plan selections, temp password required.
* ClickUp: workspace, default teams/folders permission preset.
* Jira/Confluence (Atlassian): product access, default groups/roles, site selection.
* GitHub: org selection, teams, role (member/owner), SSO required flag if applicable.
* Zoom: license type (Basic/Pro/Business), meeting/webinar add-ons.
* HubSpot: seat type, permissions set or role template.

All of the above must be configurable with sensible defaults and editable before submit.

## Provisioning Engine

* Use job queue with per-provider concurrency limits and backoff.
* Each provider must be idempotent: check existence by email or external ID, then update/assign.
* Handle rate limits with retry-after headers.
* Roll-forward on partial failure, never hide errors.
* Store raw API responses for audit.

## Security & Compliance

* Store only what you must. Encrypt secrets at rest, HTTPS in transit.
* Server-side form validation always; client validation is supplemental.
* Role-based access control: only admins can use this app.
* Audit every important action: who did what, when, against which target, with diffs.

## Config & Secrets

Document `.env.example` with:

```
ADMIN_OIDC_ISSUER=
ADMIN_OIDC_CLIENT_ID=
ADMIN_OIDC_CLIENT_SECRET=
DATABASE_URL=
REDIS_URL=
GOOGLE_ADMIN_DELEGATED_USER=
GOOGLE_CREDENTIALS_JSON=
SLACK_SCIM_TOKEN=
MS_GRAPH_TENANT_ID=
MS_GRAPH_CLIENT_ID=
MS_GRAPH_CLIENT_SECRET=
ATLASSIAN_SCIM_TOKEN=
GITHUB_APP_ID=
GITHUB_APP_PRIVATE_KEY=
ZOOM_ACCOUNT_ID=
ZOOM_CLIENT_ID=
ZOOM_CLIENT_SECRET=
HUBSPOT_PRIVATE_APP_TOKEN=
```

## Developer Experience

* Seed script to create an admin user and demo org configuration.
* Mock providers for local dev that simulate success/failure and rate limits.
* Integration tests per provider using VCR-style HTTP recording or mocks.
* Postman/Thunder collection or REST client files included.

## Deliverables

1. Source code with clear module boundaries per provider.
2. Database migrations.
3. Docker Compose for local run.
4. README with setup, scopes required, and per-provider notes.
5. Tests with coverage for provider flows, idempotency, and error handling.
6. Minimal CI script to lint, build, test.

## Acceptance Criteria (BDD style)

* “Next” disabled until name, email valid and ≥1 toggle ON.
* Given I select 3 apps and complete fields, when I submit then I see a progress view with individual app statuses updating in real time.
* If Slack rate limits, job retries with exponential backoff and respects Retry-After.
* Running the same request twice does not create duplicates; it just links existing accounts and moves to license assignment.
* An audit entry exists for each provider call with outcome and timestamp.
* Removing a license in a rerun updates the target system accordingly if supported.

## Stretch Goals (if time)

* Role templates: “Engineer,” “Sales,” etc. that pre-toggle apps and prefill fields.
* Dry-run “Plan” step that shows planned changes before apply.
* Webhook listeners for activation events to update statuses automatically.
* CSV bulk import to provision multiple users in one run.

## Clarifying Questions

Answer these before final implementation where unspecified:

1. What identity domain and email pattern should be enforced, if any?
2. Do we have admin/service accounts and required scopes for each provider, or should the app guide the admin through connecting each provider first?
3. For Google and Microsoft, which SKUs/plans are default per role? Provide the exact SKU IDs.
4. Should we enforce SSO for GitHub and Slack invites, and auto-assign default teams/groups?
5. What is the org structure: single tenant or multi-tenant? If multi-tenant, define tenant isolation requirements.
6. Any data residency requirements for the database and logs?
7. Who can access the app: a small IT admin list or anyone in the domain with a certain group membership?
8. Should licenses be downgraded or removed if a toggle is OFF on a rerun for an existing user?
9. Do we need de-provisioning flows later? If yes, specify retention rules and offboarding steps.

---

## Alternative Implementation Path (if direct API wrangling is not desired)

* Use an identity platform with SCIM provisioning and app assignment templates to centralize most of this logic. Your web app becomes a thin orchestrator that writes to the IdP and triggers downstream provisioning. This reduces API surface, centralizes audit, and improves idempotency. You’d still keep per-app customization where SCIM gaps exist.

---

